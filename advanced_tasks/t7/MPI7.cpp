#include <mpi.h>
#include <iostream>
using namespace std;

int main(int argc, char *argv[])
{
    int rank, size; // rank — ранг (id) текущего процесса, size — общее число процессов
    int value;
    MPI_Status status; // Структура для получения статуса приёма сообщений
    // MPI_Init(&argc, &argv) - Инициализация MPI, обязательна перед любыми другими MPI-функциями
	// Выполняется только один раз для каждого приложения MPI
    MPI_Init(&argc, &argv); // Передаём argc/argv, чтобы MPI обрабатывал опции командной строки
    // Получаем номер текущего параллельного процесса в коммуникаторе COMM
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    // Получаем общее число параллельных процессов в коммуникаторе COMM
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    while (true)
    {
        // Читаем значение из процесса с рангом 0
        if (rank == 0)
        {
            cout << "\nInput integer (negative for out): ";
            cin >> value;
            // Отправляем введённое значение каждому другому процессу (rank 1..size-1)
            for (int i = 1; i < size; i++)
            {
				// MPI_Send — Блокирующий отправка: выполняет операцию отправки в стандартном режиме 
                // и возвращает, когда буфер отправки можно безопасно использовать повторно
                // MPI_Send(BUF, COUNT, DATATYPE, DEST, MSGTAG, COMM)
                // Параметры функции:
                // BUF - Начальный адрес буфера отправки (на выбор)
                // COUNT - Количество элементов в буфере отправки (неотрицательное целое число)
                // DATATYPE - Тип данных (MPI_INT, MPI_FLOAT, MPI_DOUBLE и т.д.)
                // DEST - Ранг процесса-получателя
                // MSGTAG - Тег сообщения (целое число для идентификации типа сообщения)
                // COMM - Коммуникатор (дескриптор, обычно MPI_COMM_WORLD)
                MPI_Send(&value, 1, MPI_INT, i, 0, MPI_COMM_WORLD);
            }
        }
        // Все остальные процессы получают сообщение от процесса 0
        else
        {
            // MPI_Recv — Блокирующий прием: выполняет операцию получения и 
            // не возвращается, пока не будет получено соответствующее сообщение
            // MPI_Recv(BUF, COUNT, DATATYPE, DEST, MSGTAG, COMM, STATUS)
            // Параметры функции:
            // BUF - Начальный адрес буфера отправки (на выбор)
            // COUNT - Максимальное количество получаемых элементов (целое число)
            // DATATYPE - Тип данных (MPI_INT, MPI_FLOAT, MPI_DOUBLE и т.д.)
            // DEST - Ранг процесса-отправителя (или MPI_ANY_SOURCE для приёма от любого)
            // MSGTAG - Тег сообщения (или MPI_ANY_TAG для приёма с любым тегом)
            // COMM - Коммуникатор (дескриптор, обычно MPI_COMM_WORLD)
            // STATUS - Объект состояния (статус)
            MPI_Recv(&value, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, &status);
        }
        // Если введённое значение отрицательное выходим из цикла
        if (value < 0)
        {
            break;
        }
        // Печать полученного значения по порядку процессов
        for (int i = 0; i < size; i++)
        {

            // MPI_Barrier - Синхронизация между процессами MPI в группе
            // Когда первый поток завершает свою работу, то он остаётся ждать 
            // у барьера и ждёт, пока не завершат работу остальные потоки
            // MPI_Barrier(COMM)
            // Параметры функции:
            // COMM - Коммуникатор (дескриптор, обычно MPI_COMM_WORLD)
            MPI_Barrier(MPI_COMM_WORLD);

            if (rank == i)
            {
                cout << "Proc " << rank << " received value " << value << endl;
            }
        }
        // Еще раз пишем барьер чтобы процессы гарантированно завершили вывод и можно было снова взаимодействовать
        MPI_Barrier(MPI_COMM_WORLD);
    }
    // MPI_Finalize() - Завершение работы MPI.
	// Выполняется только один раз для каждого приложения MPI
	// После вызова этой функции никакие другие функции MPI не могут быть вызваны
    MPI_Finalize();

    return 0;
}
